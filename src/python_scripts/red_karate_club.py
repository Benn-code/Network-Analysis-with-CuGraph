# -*- coding: utf-8 -*-
"""Red_Karate_club.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13TRDnB3t3I-EBWIziM5V2tbQoanF6SMn
"""

# Instalación de cuDF, cuML, cuGraph y demás usando pip
!pip install cudf-cu12 cuml-cu12 cugraph-cu12 --extra-index-url=https://pypi.nvidia.com
!pip install pyvis

#prueba para comprobar nombres de las listas
import os
import pyvis

print(os.listdir(os.path.join(pyvis.__path__[0], "templates")))

import cugraph
import cudf
import matplotlib.pyplot as plt
from pyvis.network import Network
import networkx as nx

# Cargar el grafo desde NetworkX
G_nx = nx.karate_club_graph()

# Dibujar
plt.figure(figsize=(10, 8))
nx.draw(G_nx, with_labels=True, node_color='lightblue', edge_color='gray')
plt.title("Red Karate club")
plt.show()

# INTERACTIVO
###########
# Calcular el grado de cada nodo
grado = dict(G_nx.degree())
max_grado = max(grado.values())

# Crear visualización
net = Network(height="750px", width="100%", notebook=True, bgcolor="#222", font_color="white")

# Agregar nodos con colores según grado
for node in G_nx.nodes():
    g = grado[node]
    color = f"rgb({255 - int(255 * g / max_grado)}, {int(255 * g / max_grado)}, 100)"  # de rojo a verde
    size = 15 + 20 * g / max_grado
    net.add_node(node, label=str(node), color=color, size=size)

# Agregar aristas
for source, target in G_nx.edges():
    net.add_edge(source, target)

# Mostrar
net.show("red_karate_club.html")

# Convertir a cuGraph (de NetworkX a cudf dataframe)
edges = nx.to_pandas_edgelist(G_nx)
edges_cudf = cudf.DataFrame.from_pandas(edges[['source', 'target']])

# Crear grafo cuGraph
G_cu = cugraph.Graph()
G_cu.from_cudf_edgelist(edges_cudf, source='source', destination='target')

#PAGERANK
#nodos influyentes
pagerank_df = cugraph.pagerank(G_cu)
print(pagerank_df.sort_values(by='pagerank', ascending=False))
#out: indice, ID nodo, PageRank (la suma de todos da 1)

#DEGREE CENTRALITY
# Numero de conexiones de cada nodo (Grado)
centralidad = nx.degree_centrality(G_nx)
# show
for nodo, valor in centralidad.items():
    print(f"vertex {nodo}: centralidad = {valor:.4f}")
#out: nodo, distribucion de centralidad

#LOUVAIN
#encontrar grupos de nodos mas conectados entre si (comunidades)
#separacion de los grupos de karate
parts, _ = cugraph.louvain(G_cu)
print(parts)
#out: indice, ID nodo, comunidad asignada

#TRIANGLE COUNTING
#Si A-B, B-C y C-A existen, entonces {A, B, C} forma un triángulo
triangulos = nx.triangles(G_nx)  # Diccionario: nodo -> # de triángulos que contiene
total_triangulos = sum(triangulos.values()) // 3  # Cada triángulo se cuenta 3 veces

print(f"Total de triángulos en el grafo: {total_triangulos}")

#CLUSTERING COEFFICIENT
cc_local = nx.clustering(G_nx)

for nodo, cc in cc_local.items():
    print(f"{nodo}: C = {cc:.3f}")
#out: nodo, C = probabilidad de que los vecinos esten conectados/ para vallidar triangulos

#BETWEENNESS CENTRALITY
betweenness = nx.betweenness_centrality(G_nx, normalized=True)

for nodo, valor in sorted(betweenness.items(), key=lambda x: x[1], reverse=True):
    print(f"{nodo}: C_B = {valor:.4f}")
#out: nodo, que tan importante es un nodo para conectar a otros (suma 1)

